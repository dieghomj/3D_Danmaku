#include "CGame.h"
#include "CSoundManager.h"
#include "CEffect.h"	//Effekseerを使うためのクラス
#include <random>

//コンストラクタ.
CGame::CGame( CDirectX9& pDx9, CDirectX11& pDx11, HWND hWnd, CTime& pTime )
	: m_pDx9			( &pDx9 )
	, m_pDx11			( &pDx11 )
	, m_pDbgText		( nullptr )
	, m_pRayY			( nullptr )
	, m_pCrossRay		()
	, m_hWnd			( hWnd )
	, m_mView			()
	, m_mProj			()


	, m_Camera			()
	, m_Light			()

	, m_pSpriteGround	( nullptr )
	, m_pSpritePlayer	( nullptr )
	, m_pSpriteExplosion( nullptr )

	, m_pSprite2DPmon	( nullptr )

	, m_pStaticMeshFighter	( nullptr )
	, m_pStaticMeshGround	( nullptr )
	, m_pStaticMeshRoboA	( nullptr )
	, m_pStaticMeshRoboB	( nullptr )
	, m_pSpriteBullet	( nullptr )
	, m_pStaticMeshBSphere	( nullptr )

	, m_pSkinMeshZako	( nullptr ) 
	, m_ZakoAnimNo		()
	, m_ZakoAnimTime	()
	, m_ZakoBonePos		()

	, m_pExplosion		( nullptr )

	, m_pPmon			( nullptr )
	, m_pBeedrill		( nullptr )
	, m_pParasect		( nullptr )
	, m_pScyther		( nullptr )

	, m_pStcMeshObj		( nullptr )
	, m_pPlayer			( nullptr )
	, m_pEnemy			( nullptr )
	, m_pBoss			(nullptr)
	, m_pEnemies		()
	, m_ppEnemies		()
	, m_EnemyMax		( 100 )

	, m_pGround			( nullptr )

	, m_pShot			()
	, m_pBossShot		()

	, m_pZako			( nullptr )

	, m_mousePos		({0,0})
	, m_mouseBeforePos	({0,0})
	, m_mouseDelta		({ 0,0 })
	, m_mouseSense		(0.01f)

	, m_Score			(0)

	, m_pTime			(&pTime)
	, m_shotCd			(0)
	, m_bossCd			(0)
{
	//カメラ座標.
	m_Camera.vPosition	= D3DXVECTOR3( 0.0f, 2.0f, 0.0f );
	m_Camera.vLook		= D3DXVECTOR3( 0.0f, 2.0f, 10.0f );

	//ライト情報
	m_Light.vDirection = D3DXVECTOR3( 1.5f, 1.f, -1.f );	//ライト方向
}


//デストラクタ.
CGame::~CGame()
{
	//ザコ複数の破棄
	// rbegin()	:末尾を指す逆イテレータを取得
	// rend()	:先頭を指す逆イテレータを取得
	for (auto it = m_Zako.rbegin(); it != m_Zako.rend(); ++it)
	{
		SAFE_DELETE( *it );
	}


	//ザコの破棄
	SAFE_DELETE( m_pZako );

	//弾の破棄
	if (m_pShot != nullptr) {
		for (int No = BULLET_MAX - 1; No >= 0; No--) {
			SAFE_DELETE(m_pShot[No]);
		}
	}

	//地面の破棄.
	SAFE_DELETE( m_pGround );


	//エネミーの破壊
#if 1
	if (m_ppEnemies != nullptr) {
		for (int No = m_EnemyMax - 1; No >= 0; No--) {
			SAFE_DELETE(m_ppEnemies[No]);
		}
		delete[] m_ppEnemies;
		m_ppEnemies = nullptr;
	}
#else
	for (int No = ENEMY_MAX - 1; No >= 0; No--) {
		SAFE_DELETE( m_pEnemies[No] );
	}
#endif
	SAFE_DELETE(m_pBoss);
	SAFE_DELETE( m_pEnemy );

	//プレイヤーの破棄.
	SAFE_DELETE( m_pPlayer );

	//スタティックメッシュオブジェクトの破棄
	SAFE_DELETE( m_pStcMeshObj );

	//UIオブジェクトの破棄
	SAFE_DELETE( m_pScyther );
	SAFE_DELETE( m_pParasect );
	SAFE_DELETE( m_pBeedrill );
	SAFE_DELETE( m_pPmon );

	//爆発の破棄.
	SAFE_DELETE( m_pExplosion );

	//スキンメッシュの破棄
	SAFE_DELETE( m_pSkinMeshZako );

	//スタティックメッシュの破棄
	SAFE_DELETE( m_pStaticMeshBoss );
	SAFE_DELETE( m_pStaticMeshBSphere );
	SAFE_DELETE( m_pSpriteBossBullet)
	SAFE_DELETE( m_pSpriteBullet );
	SAFE_DELETE( m_pStaticMeshRoboB );
	SAFE_DELETE( m_pStaticMeshRoboA );
	SAFE_DELETE( m_pStaticMeshGround );
	SAFE_DELETE( m_pStaticMeshFighter );

	//スプライト2Dの破棄
	SAFE_DELETE( m_pSprite2DPmon );

	//爆発スプライトの解放.
	SAFE_DELETE( m_pSpriteExplosion );
	//プレイヤースプライトの解放.
	SAFE_DELETE( m_pSpritePlayer );
	//地面スプライトの解放.
	SAFE_DELETE( m_pSpriteGround );

	//レイ表示クラスの破棄
	for (int dir = CROSSRAY::max - 1; dir >= 0; dir--) {
		SAFE_DELETE( m_pCrossRay[dir] );
	}
	SAFE_DELETE( m_pRayY );

	//デバッグテキストの破棄
	SAFE_DELETE( m_pDbgText );

	//外部で作成しているので、ここでは破棄しない
	m_hWnd = nullptr;
	m_pDx11 = nullptr;
	m_pDx9 = nullptr;
}

//構築.
void CGame::Create()
{
	//デバッグテキストのインスタンス作成
	m_pDbgText = new CDebugText();

	//レイ表示クラスのインスタス作成
	m_pRayY = new CRay();
	for (int dir = 0; dir < CROSSRAY::max; dir++) {
		m_pCrossRay[dir] = new CRay();
	}

	//スプライトのインスタンス作成.
	m_pSpriteGround		= new CSprite3D();
	m_pSpritePlayer		= new CSprite3D();
	m_pSpriteExplosion	= new CSprite3D();
	m_pSpriteBullet		= new CSprite3D();
	m_pSpriteBossBullet		= new CSprite3D();

	//スプライト2Dのインスタンス作成
	m_pSprite2DPmon	= new CSprite2D();

	//スタティックメッシュのインスタンス作成
	m_pStaticMeshFighter	= new CStaticMesh();
	m_pStaticMeshGround		= new CStaticMesh();
	m_pStaticMeshRoboA		= new CStaticMesh();
	m_pStaticMeshRoboB		= new CStaticMesh();
	m_pStaticMeshBSphere	= new CStaticMesh();
	m_pStaticMeshBoss		= new CStaticMesh();

	//スキンメッシュのインスタンス作成
	m_pSkinMeshZako		= new CSkinMesh();

	//スプライトオブジェクトクラスのインスタス作成.
	m_pExplosion	= new CExplosion();

	//UIオブジェクトのインスタス作成
	m_pPmon			= new CUIObject();
	m_pBeedrill		= new CUIObject();
	m_pParasect		= new CUIObject();
	m_pScyther		= new CUIObject();

	//スタティックメッシュオブジェクトのインスタンス作成
	m_pStcMeshObj	= new CStaticMeshObject();

	//キャラクタークラスのインスタンス作成
	m_pPlayer		= new CPlayer();
	m_pEnemy		= new CEnemy();
	m_pBoss			= new CBoss();
#if 1
	//エネミーを動的に確保
	m_ppEnemies = new CEnemy*[m_EnemyMax]();
	for (int No = 0; No < m_EnemyMax; No++) {
		m_ppEnemies[No] = new CEnemy();
	}
#else
	for (int No = 0; No < ENEMY_MAX; No++) {
		m_pEnemies[No] = new CEnemy();
	}
#endif

	//地面クラスのインスタンス作成
	m_pGround = new CGround();
	m_pGround->SetPlayer(*m_pPlayer);	//レイの判定で必要

	//弾クラスのインスタンス作成
	for (int No = 0; No < BULLET_MAX; No++)
	{
		m_pShot[No] = new CShot();
		m_pBossShot[No] = new CShot();
		m_ShotQue.push(m_pShot[No]);
		m_BossShotQue.push(m_pBossShot[No]);
	}

	//ザコクラスのインスタス作成
	m_pZako = new CZako();

	//ザコ複数
	for (int i = 0; i < 3; i++) {
		//push_back(値)	:配列の末尾へ要素を追加
		//size()		:配列の要素数を取得
		m_Zako.push_back(new CZako());
	}

	//Effectクラス
	CEffect::GetInstance()->Create(
		m_pDx11->GetDevice(),
		m_pDx11->GetContext());
}

//ロードデータ関数.
HRESULT CGame::LoadData()
{
	std::random_device rd;


	//デバッグテキストの読み込み
	if (FAILED(m_pDbgText->Init( *m_pDx11 ))){
		return E_FAIL;
	}

	//サウンドデータの読み込み
	if (CSoundManager::GetInstance()->Load(m_hWnd) == false) {
		return E_FAIL;
	}

	//Effectクラス
	if (FAILED(CEffect::GetInstance()->LoadData())) {
		return E_FAIL;
	}

	//レイ表示クラスの初期化
	RAY ray = m_pPlayer->GetRayY();
	m_pRayY->Init(*m_pDx11, ray);
	for (int dir = 0; dir < CROSSRAY::max; dir++) {
		ray = m_pPlayer->GetCrossRay().Ray[dir];
		m_pCrossRay[dir]->Init(*m_pDx11, ray);
	}

	//地面スプライトの構造体
	CSprite3D::SPRITE_STATE SSGround;
	SSGround.Disp.w = 1.f;
	SSGround.Disp.h = 1.f;
	SSGround.Base.w = 256.f;
	SSGround.Base.h = 256.f;
	SSGround.Stride.w = 256.f;
	SSGround.Stride.h = 256.f;
	//地面スプライトの読み込み.
	m_pSpriteGround->Init( *m_pDx11,
		_T( "Data\\Texture\\Ground.png" ), SSGround);

	//プレイヤースプライトの構造体
	CSprite3D::SPRITE_STATE SSPlayer =
		{ 1.f, 1.f, 64.f, 64.f, 64.f, 64.f };
	//プレイヤースプライトの読み込み.
	m_pSpritePlayer->Init( *m_pDx11,
		_T( "Data\\Texture\\Player.png" ), SSPlayer);

	//爆発スプライトの構造体
	CSprite3D::SPRITE_STATE SSExplosion =
		{ 1.f, 1.f, 256.f, 256.f, 32.f, 32.f };
		//爆発スプライトの読み込み.
	m_pSpriteExplosion->Init( *m_pDx11,
		_T( "Data\\Texture\\explosion.png" ), SSExplosion);

	CSprite3D::SPRITE_STATE SSBullet =
	{ 1.f, 1.f, 64.f, 64.f, 64.f, 64.f };
	m_pSpriteBullet->Init(*m_pDx11,
		_T("Data\\Texture\\Bullet\\bullet.png"), SSBullet); 
	m_pSpriteBossBullet->Init(*m_pDx11,
			_T("Data\\Texture\\Bullet\\bossBullet.png"), SSBullet);



#if 1
	//Pモンスプライトの構造体
	CSprite2D::SPRITE_STATE SSPmon =
	{ 64.f, 64.f, 896.f, 560.f, 896.f / 16.f, 560.f / 10.f };
#else
	//Pモンスプライトの構造体
	CSprite2D::SPRITE_STATE SSPmon;
	SSPmon.Disp.w = 896.f;
	SSPmon.Disp.h = 560.f;
	SSPmon.Base = SSPmon.Stride = SSPmon.Disp;
#endif
	//Pモンスプライトの読み込み
	m_pSprite2DPmon->Init( *m_pDx11,
		_T( "Data\\Texture\\pmon.png" ), SSPmon );

	//スタティックメッシュの読み込み
	m_pStaticMeshFighter->Init( *m_pDx9, *m_pDx11,
		_T( "Data\\Mesh\\Static\\Fighter\\Fighter.x" ) );
	m_pStaticMeshGround->Init( *m_pDx9, *m_pDx11,
		_T("Data\\Mesh\\Static\\Ground\\ground.x" ));
		//_T("Data\\Mesh\\Static\\Stage\\stage.x"));
	m_pStaticMeshRoboA->Init(*m_pDx9, *m_pDx11,
		_T("Data\\Mesh\\Static\\Robo\\RobotA_pivot.x"));
	m_pStaticMeshRoboB->Init(*m_pDx9, *m_pDx11,
		_T("Data\\Mesh\\Static\\Robo\\RobotB_pivot.x"));
	//ボスの読み込み
	m_pStaticMeshBoss->Init(*m_pDx9, *m_pDx11,
		_T("Data\\Mesh\\Static\\Boss\\boss.x"));

	//バウンディングスフィア(当たり判定用)
	m_pStaticMeshBSphere->Init(*m_pDx9, *m_pDx11,
		_T("Data\\Collision\\Sphere.x"));


	//スキンメッシュの読み込み
	m_pSkinMeshZako->Init(*m_pDx9, *m_pDx11,
		_T("Data\\Mesh\\Skin\\zako\\zako.x"));

	//爆発スプライトを設定.
	m_pExplosion->AttachSprite( *m_pSpriteExplosion );
	m_pExplosion->SetScale(2.0f);
	for (int No = 0; No < BULLET_MAX; No++) {
		m_pShot[No]->AttachSprite(*m_pSpriteBullet);
		m_pBossShot[No]->AttachSprite(*m_pSpriteBossBullet);
	}

	//Pモンスプライトを設定
	m_pPmon->AttachSprite( *m_pSprite2DPmon );
	m_pBeedrill->AttachSprite( *m_pSprite2DPmon );
	m_pParasect->AttachSprite( *m_pSprite2DPmon );
	m_pScyther->AttachSprite( *m_pSprite2DPmon );

	//スタティックメッシュを設定
	m_pStcMeshObj->AttachMesh( *m_pStaticMeshFighter );
	m_pPlayer->AttachMesh( *m_pStaticMeshFighter );
	m_pPlayer->SetScale(2.f);
	m_pGround->AttachMesh( *m_pStaticMeshGround );
	m_pEnemy->AttachMesh( *m_pStaticMeshRoboB );
	m_pBoss->AttachMesh(*m_pStaticMeshBoss);

	//スキンメッシュを設定
	m_pZako->AttachMesh( *m_pSkinMeshZako );
	m_pZako->SetScale( 0.002f );
	m_pZako->SetPosition( 0.f, 0.f, 8.f );

	//ザコ複数
	//範囲for文
	//auto:自動で型を推論、&をつけると参照になり不要なコピーを避けれる
	for (auto& e : m_Zako)
	{
		int i = static_cast<int>(&e - &m_Zako[0]);	//現在のインデックス番号算出

		e->SetPosition( -3.f + ( i * 3.f ), 0.f, 12.f);
		e->SetScale( 0.002f );
		e->AttachMesh( *m_pSkinMeshZako );
		e->SetAnimSpeed( 0.0001 + ( i * 0.0001 ) );
	}

	//Pモンそれぞれの画像パターンを設定
	m_pBeedrill->SetPatternNo( 14, 0 );
	m_pParasect->SetPatternNo( 14, 2 );
	m_pScyther->SetPatternNo( 10, 7 );

	//Pモンそれぞれの位置を設定
	const float size = SSPmon.Disp.w * 0.5f;	// 64.f
	const float pos_y = static_cast<float>(WND_H) - SSPmon.Disp.h;
	m_pBeedrill->SetPosition( size * 0.f, pos_y, 0.f );
	m_pParasect->SetPosition( size * 1.f, pos_y, 0.f );
	m_pScyther->SetPosition(  size * 2.f, pos_y, 0.f );

	//バウンディングスフィアの作成
	m_pPlayer->CreateBSphereForMesh(*m_pStaticMeshBSphere);
	m_pEnemy->CreateBSphereForMesh(*m_pStaticMeshBSphere);
	m_pBoss->CreateBSphereForMesh(*m_pStaticMeshBSphere);

	//m_pShot->CreateBSphereForMesh(*m_pStaticMeshBullet);

	//キャラクターの初期座標を設定
	m_pPlayer->SetPosition( 0.f, 1.f, 6.f );
	m_pEnemy->SetPosition( 0.f, -10.f, 16.f );
	m_pBoss->SetPosition( 0.f, -10.f, 0.f );
	m_pBoss->SetScale(3.0);
	//エネミー複数設定
#if 1
	for (int No = 0; No < m_EnemyMax; No++) {
		auto& pE = m_ppEnemies[No];
		std::mt19937 gen(rd());
		std::uniform_real_distribution<float> dis(0.0, 1.0f);
		float rng = dis(gen);
		//ランダムでAかBを選択して設定
		if (rng < 0.25f)
		{
			CreateElite(pE);
			pE->Respawn();
		}
		else
		{
			pE->AttachMesh(*m_pStaticMeshRoboA);
			pE->SetScale(1.0f);
			pE->CreateBSphereForMesh(*m_pStaticMeshBSphere);
			pE->Respawn();
		}
	}
#else
	for (int No = 0; No < ENEMY_MAX; No++) {
		auto& pE = m_pEnemies[No];
		pE->AttachMesh(*m_pStaticMeshRoboA);
		pE->CreateBSphereForMesh(*m_pStaticMeshBSphere);
		pE->SetPosition(-3.f + (No * 3.f), 1.f, 10.f);
	}
#endif

	return S_OK;
}



//解放関数.
void CGame::Release()
{
}


//更新処理.
void CGame::Update()
{
	//BGMのループ再生
	//CSoundManager::PlayLoop(CSoundManager::BGM_Bonus);
	
	POINT mousePos;
	GetCursorPos(&mousePos);
	ScreenToClient(m_hWnd, &mousePos);

	// Calculate delta from center
	POINT center = { WND_W / 2, WND_H / 2 };
	m_mouseDelta.x = mousePos.x - center.x;
	m_mouseDelta.y = mousePos.y - center.y;

	// Reset cursor to center
	ClientToScreen(m_hWnd, &center);
	SetCursorPos(center.x, center.y);

	if (m_pPlayer->GetHealth() <= 0.f)
	{
		m_GameState = enGameScene::GameOver;
		m_pPlayer->SetPosition(0.f, -2.f, 0.f);
	}
	if (m_Score > 5000)
	{
		m_pPlayer->SetShotType(CPlayer::Triple);
	}
	else if(m_Score > 1000)
		m_pPlayer->SetShotType(CPlayer::Double);

	m_pPlayer->Update();
	m_pPlayer->TickInvTimer(m_pTime->GetFixedDeltaTime()/1000.f);

	m_pGround->Update();

	if (m_pBoss->IsShot() == true) 
	{
		for (int No = 0; No < BULLET_MAX; No++)
		{
			float cadence = m_bossCd;					//連射速度
			m_bossCd -= m_pTime->GetFixedDeltaTime();	//連射速度を減少
			if (m_bossCd <= 0.0f)
			{
				CShot* bullet = m_BossShotQue.front();
				bullet->Reload(
					m_pBoss->GetPosition(),
					m_pBoss->GetRotation().y);
				//弾をキューの最後に移動
				m_bossCd = m_pBoss->GetShootCd();

				m_BossShotQue.pop();
				m_BossShotQue.push(bullet);
			}

		}
	}

#if 1
	//弾を飛ばしたい!
	int bulletCount = m_pPlayer->GetShotNumber() + 1; // existing convention: enum value + 1
	HandlePlayerShot();

#else
	//弾を飛ばしたい!
	//dynamic_cast：親クラスのポインタを子クラスのポインタに変換する
	if (dynamic_cast<CPlayer*>(m_pPlayer)->IsShot() == true) {
		m_pShot->Reload(m_pPlayer->GetPosition());
	}
#endif
	for (int sNo = 0; sNo < BULLET_MAX; sNo++) {

		m_pShot[sNo]->Update();
		m_pBossShot[sNo]->Update();
	}

	for (int No = 0; No < m_EnemyMax; No++) {
		m_ppEnemies[No]->SetTargetPos(m_pPlayer->GetPosition());
		m_ppEnemies[No]->Update();
	}

	if (m_Score >= 50 && m_pBoss->GetEnemyState() == CEnemy::DESPAWN && m_GameState != enGameScene::Result)
	{
		m_pBoss->SetEnemyState(CEnemy::CHASING);
		m_pBoss->SetPosition(0.f, 1.f, m_pPlayer->GetPosition().z + 100.f);
	}

	m_pBoss->Update();
	m_pBoss->SetTargetPos(m_pPlayer->GetPosition());

#if 1
#else
	for (int No = 0; No < ENEMY_MAX; No++) {
		m_pEnemies[No]->Update();
	}
#endif

	m_pExplosion->Update();

	TopDownCamera(
		&m_Camera,
		m_pPlayer->GetPosition(),
		m_pPlayer->GetRotation().y);

	CameraRotToMouse(
		&m_Camera,
		m_pPlayer->GetPosition(),
		m_mouseDelta,
		m_mouseSense);

	float rotX = m_Camera.yaw;
	m_pPlayer->SetRotation(0, rotX, 0);

	////三人称カメラ
	//ThirdPersonCamera(
	//	&m_Camera,
	//	m_pPlayer->GetPosition(),
	//	m_pPlayer->GetRotation().y);
}

//描画処理.
void CGame::Draw()
{
	Camera();
	Projection();

#if 1
	m_pGround->Draw( m_mView, m_mProj, m_Light, m_Camera );

	m_pPlayer->Draw( m_mView, m_mProj, m_Light, m_Camera );

	m_pBoss->Draw(m_mView, m_mProj, m_Light, m_Camera);

#if 1
	for (int No = 0; No < m_EnemyMax; No++) {
		m_ppEnemies[No]->Draw( m_mView, m_mProj, m_Light, m_Camera );
	}
#else
	for (int No = 0; No < ENEMY_MAX; No++) {
		m_pEnemies[No]->Draw( m_mView, m_mProj, m_Light, m_Camera );
	}
#endif

	//当たり判定の中心座標を更新する
	m_pPlayer->UpdateBSpherePos();
	m_pEnemy->UpdateBSpherePos();
	m_pBoss->UpdateBSpherePos();
	//m_pShot->UpdateBSpherePos();

	//プレイヤーとエネミーの当たり判定
	if (m_pPlayer->GetBSphere()->IsHit(*m_pBoss->GetBSphere()))
	{
		m_pPlayer->SetDamageValue(20);
	}
	else
	{
		SetWindowText(m_hWnd, _T(""));
	}

	for (int i = 0; i < m_EnemyMax; i++) {
		m_ppEnemies[i]->UpdateBSpherePos();
	}

	//弾とエネミーの当たり判定
	for (int eNo = 0; eNo < m_EnemyMax; eNo++)
	{
		//プレイヤーとエネミーの当たり判定
		if (m_pPlayer->GetBSphere()->IsHit(*m_ppEnemies[eNo]->GetBSphere()))
		{
			m_pPlayer->SetDamageValue(5);
			
			
		}

		for (int No = 0; No < BULLET_MAX; No++)
		{
			if (m_pShot[No]->IsHit(m_ppEnemies[eNo], 1.f))
			{
				m_pExplosion->SetPosition(m_ppEnemies[eNo]->GetPosition());	//エネミーの位置にそろえる
				dynamic_cast<CExplosion*>(m_pExplosion)->ResetAnimation();//アニメーションリセット
				m_pShot[No]->SetDisplay(false);
				m_pShot[No]->SetPosition(0.f, -10.f, 0.f);	//地面に埋める
				m_ppEnemies[eNo]->SetDamagedValue(10.f);
				if (m_ppEnemies[eNo]->GetHealth() <= 0.f)
				{
					m_Score += 10;
				}
			}


		}
	}

	for (int No = 0; No < BULLET_MAX; No++)
	{

		if (m_pBossShot[No]->IsHit(m_pPlayer, 0.01))
		{
			m_pPlayer->SetDamageValue(10);

			m_pExplosion->SetPosition(m_pPlayer->GetPosition());	//エネミーの位置にそろえる
			dynamic_cast<CExplosion*>(m_pExplosion)->ResetAnimation();//アニメーションリセット
			//弾
			m_pBossShot[No]->SetDisplay(false);
			m_pBossShot[No]->SetPosition(0.f, -10.f, 0.f);	//地面に埋める
		}

		if (m_pShot[No]->IsHit(m_pBoss, 0.1))
		{
			//爆発
			m_pExplosion->SetPosition(m_pBoss->GetPosition());	//エネミーの位置にそろえる
			dynamic_cast<CExplosion*>(m_pExplosion)->ResetAnimation();//アニメーションリセット
			//弾
			m_pShot[No]->SetDisplay(false);
			m_pShot[No]->SetPosition(0.f, -10.f, 0.f);	//地面に埋める
			m_pBoss->SetDamagedValue(10);
			if (m_pBoss->GetHealth() <= 0)
			{
				m_GameState = enGameScene::Result;
				m_Score += 10000;
				m_pBoss->SetPosition(0.f,-10.f,0.f);
			}
		}

	}

	m_pExplosion->Draw(m_mView, m_mProj);
	for (int No = 0; No < BULLET_MAX; No++) {
		m_pShot[No]->Draw(m_mView, m_mProj);
		m_pBossShot[No]->Draw(m_mView, m_mProj);
	}

#else
	//ゲームオブジェクトのポインタのリストを作成
	CGameObject* pObjList[] =
	{
		m_pGround,
		m_pPlayer,
		m_pExplosion,
		m_pPmon,
		m_pBeedrill,
		m_pParasect,
		m_pScyther,
	};
	//配列の最大要素数を算出
	const int ObjListMax = sizeof(pObjList) / sizeof(pObjList[0]);
	//作成したリストでループ処理する
	for (int i = 0; i < ObjListMax; i++) {
		pObjList[i]->Draw( m_mView, m_mProj, m_Light, m_Camera );
	}

#endif

	//Effectクラス
	CEffect::GetInstance()->Draw(m_mView, m_mProj, m_Light, m_Camera);

	//レイの描画
	m_pRayY->Render(m_mView, m_mProj, m_pPlayer->GetRayY());
	for (int dir = 0; dir < CROSSRAY::max; dir++) {
		m_pCrossRay[dir]->Render(
			m_mView, m_mProj, m_pPlayer->GetCrossRay().Ray[dir]);
	}

	//デバッグテキスト(数値入り)の描画
	m_pDbgText->SetColor(1.f, 1.f, 1.f);
	TCHAR dbgText[64];
	_stprintf_s(dbgText, _T("SCORE:%d"), m_Score);
	m_pDbgText->Render( dbgText, 10, 110 );
	m_pDbgText->SetColor(1.f, 1.f, 1.f);
	_stprintf_s(dbgText, _T("HEALTH:%d"), m_pPlayer->GetHealth() );
	m_pDbgText->Render(dbgText, 10, 150);

	_stprintf_s(dbgText, _T("TIME:%.2f"), m_pTime->GetTotalTime()/1000.f);
	m_pDbgText->Render(dbgText, 10, 100);
}

//カメラ関数.
//※カメラ専用のクラスを作成したら便利だよ.
void CGame::Camera()
{
	D3DXVECTOR3 cam_pos	= m_Camera.vPosition;
	D3DXVECTOR3 cam_look = m_Camera.vLook;
	D3DXVECTOR3	vUpVec( 0.0f, 1.0f, 0.0f );	//上方（ベクトル）.

	//ビュー（カメラ）変換.
	D3DXMatrixLookAtLH(
		&m_mView,	//(out)ビュー計算結果.
		&cam_pos, &cam_look, &vUpVec );
}

//プロジェクション関数.
void CGame::Projection()
{
	//y方向の視野角。数値を大きくしたら視野が狭くなる.
	float fov_y	 = static_cast<FLOAT>( D3DXToRadian( 45.0 ) );	//ラジアン値.
	//アスペクト（幅÷高さ）.
	float aspect = static_cast<FLOAT>( WND_W ) / static_cast<FLOAT>( WND_H );
	float near_z = 0.1f;
	float far_z	 = 100.0f;

	//プロジェクション（射影）変換.
	D3DXMatrixPerspectiveFovLH(
		&m_mProj,	//(out)プロジェクション計算結果.
		fov_y,		//視野角（FOV：Field of View）.
		aspect,		//アスペクト.
		near_z,		//近いビュー平面のz値.
		far_z );	//遠いビュー平面のz値.
}

//三人称カメラ
void CGame::ThirdPersonCamera(
	CAMERA* pCamera, const D3DXVECTOR3& TargetPos, float TargetRotY)
{
	//Z軸ベクトル（Z+方向の単位ベクトル）
	D3DXVECTOR3 vecAxisZ(0.f, 0.f, 1.f);

	//Y方向の回転行列
	D3DXMATRIX mRotationY;
	//Y軸回転行列を作成
	D3DXMatrixRotationY(
		&mRotationY,	//(out)行列
		TargetRotY);	//対象のY方向の回転値

	//Y軸回転行列を使ってZ軸ベクトルを座標変換する
	D3DXVec3TransformCoord(
		&vecAxisZ,		//(out)Z軸ベクトル
		&vecAxisZ,		//(in)Z軸ベクトル
		&mRotationY);	//Y軸回転行列

	//カメラの位置、注視位置を対象にそろえる
	pCamera->vPosition	= TargetPos;
	pCamera->vLook		= TargetPos;

	//カメラの位置、注視位置をZ軸ベクトルを用いて調整
	pCamera->vPosition	-= vecAxisZ * 4.f;	//対象の背中側
	pCamera->vLook		+= vecAxisZ * 3.f;	//対象を挟んで向こう側

	//カメラの位置、注視位置の高さをそれぞれ微調整
	pCamera->vPosition.y+= 2.f;
	pCamera->vLook.y	+= 0.5f;
}


void CGame::TopDownCamera(
	CAMERA* pCamera, const D3DXVECTOR3& TargetPos, float TargetRotY)
{
	//Z軸ベクトル（Z+方向の単位ベクトル）
	D3DXVECTOR3 vecAxisY(0.f, 1.f, 0.f);
	D3DXVECTOR3 vecAxisZ(0.f, 0.f, 1.f);

	//Y方向の回転行列
	D3DXMATRIX mRotationY;
	//Y軸回転行列を作成
	D3DXMatrixRotationY(
		&mRotationY,	//(out)行列
		TargetRotY);	//対象のY方向の回転値

	//Y軸回転行列を使ってZ軸ベクトルを座標変換する
	D3DXVec3TransformCoord(
		&vecAxisZ,		//(out)Z軸ベクトル
		&vecAxisZ,		//(in)Z軸ベクトル
		&mRotationY);	//Y軸回転行列

	pCamera->vPosition	= TargetPos;
	pCamera->vLook		= TargetPos;

	pCamera->vPosition	+= vecAxisY * 25.f ;
	pCamera->vLook		+= vecAxisZ * 8.f - vecAxisY * 1.f;

}

void CGame::CameraRotToMouse(CAMERA* pCamera, const D3DXVECTOR3& TargetPos, POINT delta, float sense)
{

	pCamera->yaw += (float)delta.x * sense;

	D3DXVECTOR3 lookDirection;
	lookDirection.x = cosf(pCamera->pitch) * sinf(pCamera->yaw);
	lookDirection.y = sinf(pCamera->pitch);
	lookDirection.z = cosf(pCamera->pitch) * cosf(pCamera->yaw);

	D3DXVECTOR3 position = D3DXVECTOR3(TargetPos.x, 0, TargetPos.z);

	pCamera->vLook =  position + lookDirection;

}

float CGame::GetNWayRot(float spreadDeg, int bulletCount, int bulletNo)
{
	const float spreadRad = (bulletCount > 1) ? D3DXToRadian(spreadDeg) : 0.0f;
	const float startAngle = -spreadRad * 0.5f; // start relative to forward (-half spread)
	const float angleStep = (bulletCount > 1) ? (spreadRad / (bulletCount - 1)) : 0.0f;

	return startAngle + angleStep * bulletNo;

}



void CGame::HandlePlayerShot()
{
	if (m_ShotQue.empty())		//弾が無いので発射できない
		return;
	
	int bulletCount = m_pPlayer->GetShotNumber() + 1;				//連射数
	m_pPlayer->DecCadenceTimer(m_pTime->GetFixedDeltaTime());	//連射速度を減少
	//連射速度を超えたら弾を発射

	if (m_pPlayer->IsShot() == true)
	{
		switch (m_pPlayer->GetShotType())
		{
		default:
		case CCharacter::Simple:
			HandleNWayShot(bulletCount);
			break;
		case CCharacter::Charged:
			HandleChargedShot();
			break;
		case CCharacter::Homing:
			break;

		}

	}
}

void CGame::HandleChargedShot()
{
	std::vector<CShot*> tempShots;
	tempShots.clear();

	for (int No = 0; No < m_ShotQue.size(); No++)
	{
		CShot* bullet = m_ShotQue.front();		//キューの先頭を取得
		float ratio = 1.0f + m_pPlayer->ChargedTime/m_pPlayer->GetChargedShotMax();
		bullet->SetScale(ratio);			//大きくする
		bullet->Reload(
		m_pPlayer->GetPosition(),
		m_pPlayer->GetRotation().y);
	}

}

void CGame::HandleNWayShot(int bulletCount)
{
	//NWay弾を発射
	for (int No = 0; No < bulletCount; No++)
	{
		CShot* bullet = m_ShotQue.front();		//キューの先頭を取得

		const float rotY =
			m_pPlayer->GetRotation().y +
			GetNWayRot(m_pPlayer->GetNWaySpreadDeg(), bulletCount, No);	//弾のY軸回転を計算

		bullet->Reload(
			m_pPlayer->GetPosition(),
			rotY);


		//弾をキューの最後に移動
		m_ShotQue.pop();
		m_ShotQue.push(bullet);
	}

}

void CGame::CreateElite(CEnemy*& enemy)
{
	enemy->AttachMesh(*m_pStaticMeshRoboB);
	enemy->SetScale(3.0f);
	enemy->CreateBSphereForMesh(*m_pStaticMeshBSphere);
	enemy->SetHealth(100);
}